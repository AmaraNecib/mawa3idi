// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package DB

import (
	"context"
	"database/sql"
	"time"
)

const createCategory = `-- name: CreateCategory :exec
INSERT INTO categories (name, description)
VALUES ($1, $2)
`

type CreateCategoryParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, createCategory, arg.Name, arg.Description)
	return err
}

const createComplaint = `-- name: CreateComplaint :exec
INSERT INTO complaints (service_id, user_id, type, complaint)
VALUES ($1, $2, $3, $4)
`

type CreateComplaintParams struct {
	ServiceID int32  `json:"service_id"`
	UserID    int32  `json:"user_id"`
	Type      string `json:"type"`
	Complaint string `json:"complaint"`
}

func (q *Queries) CreateComplaint(ctx context.Context, arg CreateComplaintParams) error {
	_, err := q.db.ExecContext(ctx, createComplaint,
		arg.ServiceID,
		arg.UserID,
		arg.Type,
		arg.Complaint,
	)
	return err
}

const createDay = `-- name: CreateDay :exec
INSERT INTO days (name) VALUES ($1)
`

func (q *Queries) CreateDay(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createDay, name)
	return err
}

const createRating = `-- name: CreateRating :exec
INSERT INTO ratings (service_id, user_id, rating, comment)
VALUES ($1, $2, $3, $4)
`

type CreateRatingParams struct {
	ServiceID int32          `json:"service_id"`
	UserID    int32          `json:"user_id"`
	Rating    int32          `json:"rating"`
	Comment   sql.NullString `json:"comment"`
}

func (q *Queries) CreateRating(ctx context.Context, arg CreateRatingParams) error {
	_, err := q.db.ExecContext(ctx, createRating,
		arg.ServiceID,
		arg.UserID,
		arg.Rating,
		arg.Comment,
	)
	return err
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (service_id, user_id, time, weekday_id, ranking, reserve_type)
VALUES ($1, $2, $3, $4, $5, 1)
RETURNING id, service_id, user_id, time, weekday_id, ranking, reserve_type, created_at, updated_at
`

type CreateReservationParams struct {
	ServiceID int32     `json:"service_id"`
	UserID    int32     `json:"user_id"`
	Time      time.Time `json:"time"`
	WeekdayID int32     `json:"weekday_id"`
	Ranking   int32     `json:"ranking"`
}

type CreateReservationRow struct {
	ID          int64        `json:"id"`
	ServiceID   int32        `json:"service_id"`
	UserID      int32        `json:"user_id"`
	Time        time.Time    `json:"time"`
	WeekdayID   int32        `json:"weekday_id"`
	Ranking     int32        `json:"ranking"`
	ReserveType int32        `json:"reserve_type"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (CreateReservationRow, error) {
	row := q.db.QueryRowContext(ctx, createReservation,
		arg.ServiceID,
		arg.UserID,
		arg.Time,
		arg.WeekdayID,
		arg.Ranking,
	)
	var i CreateReservationRow
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.UserID,
		&i.Time,
		&i.WeekdayID,
		&i.Ranking,
		&i.ReserveType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReserveStatus = `-- name: CreateReserveStatus :exec
INSERT INTO reservations_status (name) VALUES ($1)
`

func (q *Queries) CreateReserveStatus(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createReserveStatus, name)
	return err
}

const createReserveType = `-- name: CreateReserveType :one

INSERT INTO reserve_types (name) VALUES ($1) RETURNING id, name, created_at, updated_at
`

func (q *Queries) CreateReserveType(ctx context.Context, name string) (ReserveType, error) {
	row := q.db.QueryRowContext(ctx, createReserveType, name)
	var i ReserveType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRole = `-- name: CreateRole :exec
INSERT INTO roles (name)
VALUES ($1)
`

func (q *Queries) CreateRole(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createRole, name)
	return err
}

const createService = `-- name: CreateService :exec
INSERT INTO services (user_id, description, google_map_address, willaya, baladia, subcategory_id)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateServiceParams struct {
	UserID           int32  `json:"user_id"`
	Description      string `json:"description"`
	GoogleMapAddress string `json:"google_map_address"`
	Willaya          string `json:"willaya"`
	Baladia          string `json:"baladia"`
	SubcategoryID    int32  `json:"subcategory_id"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) error {
	_, err := q.db.ExecContext(ctx, createService,
		arg.UserID,
		arg.Description,
		arg.GoogleMapAddress,
		arg.Willaya,
		arg.Baladia,
		arg.SubcategoryID,
	)
	return err
}

const createSubcategory = `-- name: CreateSubcategory :exec
INSERT INTO subcategories (name, description, category_id)
VALUES ($1, $2, $3)
`

type CreateSubcategoryParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	CategoryID  int32  `json:"category_id"`
}

func (q *Queries) CreateSubcategory(ctx context.Context, arg CreateSubcategoryParams) error {
	_, err := q.db.ExecContext(ctx, createSubcategory, arg.Name, arg.Description, arg.CategoryID)
	return err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (first_name, last_name, phone_number, email, password, role_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id,first_name, last_name, phone_number, email, role_id, created_at, updated_at
`

type CreateUserParams struct {
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	PhoneNumber string `json:"phone_number"`
	Email       string `json:"email"`
	Password    string `json:"password"`
	RoleID      int32  `json:"role_id"`
}

type CreateUserRow struct {
	ID          int64        `json:"id"`
	FirstName   string       `json:"first_name"`
	LastName    string       `json:"last_name"`
	PhoneNumber string       `json:"phone_number"`
	Email       string       `json:"email"`
	RoleID      int32        `json:"role_id"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
}

// Create Operations
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Email,
		arg.Password,
		arg.RoleID,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWorkday = `-- name: CreateWorkday :exec
INSERT INTO workdays (service_id, name, start_time, end_time, max_clients,day_id, open_to_work)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateWorkdayParams struct {
	ServiceID  int32     `json:"service_id"`
	Name       string    `json:"name"`
	StartTime  time.Time `json:"start_time"`
	EndTime    time.Time `json:"end_time"`
	MaxClients int32     `json:"max_clients"`
	DayID      int32     `json:"day_id"`
	OpenToWork bool      `json:"open_to_work"`
}

func (q *Queries) CreateWorkday(ctx context.Context, arg CreateWorkdayParams) error {
	_, err := q.db.ExecContext(ctx, createWorkday,
		arg.ServiceID,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
		arg.MaxClients,
		arg.DayID,
		arg.OpenToWork,
	)
	return err
}

const deleteCategoryByID = `-- name: DeleteCategoryByID :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategoryByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCategoryByID, id)
	return err
}

const deleteComplaintByID = `-- name: DeleteComplaintByID :exec
DELETE FROM complaints
WHERE id = $1
`

func (q *Queries) DeleteComplaintByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteComplaintByID, id)
	return err
}

const deleteRatingByID = `-- name: DeleteRatingByID :exec
DELETE FROM ratings
WHERE id = $1
`

func (q *Queries) DeleteRatingByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRatingByID, id)
	return err
}

const deleteReservationByID = `-- name: DeleteReservationByID :exec
DELETE FROM reservations
WHERE id = $1
`

func (q *Queries) DeleteReservationByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteReservationByID, id)
	return err
}

const deleteReserveTypeByID = `-- name: DeleteReserveTypeByID :exec
DELETE FROM reserve_types WHERE id = $1
`

func (q *Queries) DeleteReserveTypeByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteReserveTypeByID, id)
	return err
}

const deleteRoleByID = `-- name: DeleteRoleByID :exec
DELETE FROM roles
WHERE id = $1
`

func (q *Queries) DeleteRoleByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRoleByID, id)
	return err
}

const deleteServiceByID = `-- name: DeleteServiceByID :exec
DELETE FROM services
WHERE id = $1
`

func (q *Queries) DeleteServiceByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteServiceByID, id)
	return err
}

const deleteSubcategoryByID = `-- name: DeleteSubcategoryByID :exec
DELETE FROM subcategories
WHERE id = $1
`

func (q *Queries) DeleteSubcategoryByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSubcategoryByID, id)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec

DELETE FROM users
WHERE id = $1
`

// Delete Operations
func (q *Queries) DeleteUserByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserByID, id)
	return err
}

const deleteWorkdayByID = `-- name: DeleteWorkdayByID :exec
DELETE FROM workdays
WHERE id = $1
`

func (q *Queries) DeleteWorkdayByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteWorkdayByID, id)
	return err
}

const delteAllRoles = `-- name: DelteAllRoles :exec
DELETE FROM roles
`

func (q *Queries) DelteAllRoles(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, delteAllRoles)
	return err
}

const getAllDays = `-- name: GetAllDays :many
SELECT id, name, created_at, updated_at FROM days ORDER BY id
`

func (q *Queries) GetAllDays(ctx context.Context) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, getAllDays)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Day
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReserveStatus = `-- name: GetAllReserveStatus :many
SELECT id, name, created_at, updated_at FROM reservations_status
`

func (q *Queries) GetAllReserveStatus(ctx context.Context) ([]ReservationsStatus, error) {
	rows, err := q.db.QueryContext(ctx, getAllReserveStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReservationsStatus
	for rows.Next() {
		var i ReservationsStatus
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT id, name, description, created_at, updated_at FROM categories
`

func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, description, created_at, updated_at FROM categories WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id int64) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getComplaintsByUserID = `-- name: GetComplaintsByUserID :many
SELECT id, service_id, user_id, type, complaint, created_at, updated_at FROM complaints WHERE user_id = $1
`

func (q *Queries) GetComplaintsByUserID(ctx context.Context, userID int32) ([]Complaint, error) {
	rows, err := q.db.QueryContext(ctx, getComplaintsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Complaint
	for rows.Next() {
		var i Complaint
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.UserID,
			&i.Type,
			&i.Complaint,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDaysOfWorkByServiceID = `-- name: GetDaysOfWorkByServiceID :many
SELECT workdays.id, workdays.service_id, workdays.name, workdays.open_to_work, workdays.day_id, workdays.start_time, workdays.end_time, workdays.max_clients, workdays.created_at, workdays.updated_at FROM workdays JOIN services ON workdays.service_id = services.id WHERE services.id = $1
`

func (q *Queries) GetDaysOfWorkByServiceID(ctx context.Context, id int64) ([]Workday, error) {
	rows, err := q.db.QueryContext(ctx, getDaysOfWorkByServiceID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workday
	for rows.Next() {
		var i Workday
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Name,
			&i.OpenToWork,
			&i.DayID,
			&i.StartTime,
			&i.EndTime,
			&i.MaxClients,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingsByServiceID = `-- name: GetRatingsByServiceID :many
SELECT id, service_id, user_id, rating, comment, created_at, updated_at FROM ratings WHERE service_id = $1
`

func (q *Queries) GetRatingsByServiceID(ctx context.Context, serviceID int32) ([]Rating, error) {
	rows, err := q.db.QueryContext(ctx, getRatingsByServiceID, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rating
	for rows.Next() {
		var i Rating
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.UserID,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservationsByServiceID = `-- name: GetReservationsByServiceID :many
SELECT id, service_id, user_id, time, weekday_id, ranking, reserve_type, reserv_status, created_at, updated_at FROM reservations WHERE service_id = $1
`

func (q *Queries) GetReservationsByServiceID(ctx context.Context, serviceID int32) ([]Reservation, error) {
	rows, err := q.db.QueryContext(ctx, getReservationsByServiceID, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reservation
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.UserID,
			&i.Time,
			&i.WeekdayID,
			&i.Ranking,
			&i.ReserveType,
			&i.ReservStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservationsByUserID = `-- name: GetReservationsByUserID :many
SELECT id, service_id, user_id, time, weekday_id, ranking, reserve_type, reserv_status, created_at, updated_at FROM reservations WHERE user_id = $1
`

func (q *Queries) GetReservationsByUserID(ctx context.Context, userID int32) ([]Reservation, error) {
	rows, err := q.db.QueryContext(ctx, getReservationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reservation
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.UserID,
			&i.Time,
			&i.WeekdayID,
			&i.Ranking,
			&i.ReserveType,
			&i.ReservStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservationsByWeekdayID = `-- name: GetReservationsByWeekdayID :many
SELECT id, service_id, user_id, time, weekday_id, ranking, reserve_type, reserv_status, created_at, updated_at FROM reservations
WHERE created_at::date = $1::date
`

func (q *Queries) GetReservationsByWeekdayID(ctx context.Context, dollar_1 time.Time) ([]Reservation, error) {
	rows, err := q.db.QueryContext(ctx, getReservationsByWeekdayID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reservation
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.UserID,
			&i.Time,
			&i.WeekdayID,
			&i.Ranking,
			&i.ReserveType,
			&i.ReservStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservationsCount = `-- name: GetReservationsCount :one
SELECT  COUNT(*) FROM reservations WHERE service_id = $1 AND time = $2 AND weekday_id = $3
`

type GetReservationsCountParams struct {
	ServiceID int32     `json:"service_id"`
	Time      time.Time `json:"time"`
	WeekdayID int32     `json:"weekday_id"`
}

func (q *Queries) GetReservationsCount(ctx context.Context, arg GetReservationsCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReservationsCount, arg.ServiceID, arg.Time, arg.WeekdayID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getReservationsCountByUserIdAndServiceId = `-- name: GetReservationsCountByUserIdAndServiceId :one
SELECT  COUNT(*) FROM reservations WHERE user_id = $1 AND service_id = $2 AND time = $3 AND weekday_id = $4
`

type GetReservationsCountByUserIdAndServiceIdParams struct {
	UserID    int32     `json:"user_id"`
	ServiceID int32     `json:"service_id"`
	Time      time.Time `json:"time"`
	WeekdayID int32     `json:"weekday_id"`
}

func (q *Queries) GetReservationsCountByUserIdAndServiceId(ctx context.Context, arg GetReservationsCountByUserIdAndServiceIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReservationsCountByUserIdAndServiceId,
		arg.UserID,
		arg.ServiceID,
		arg.Time,
		arg.WeekdayID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getReservationsCountForUpdate = `-- name: GetReservationsCountForUpdate :one
SELECT COUNT(*)
FROM reservations
WHERE weekday_id = $1
  AND service_id = $2
  AND time = $3
FOR UPDATE
`

type GetReservationsCountForUpdateParams struct {
	WeekdayID int32     `json:"weekday_id"`
	ServiceID int32     `json:"service_id"`
	Time      time.Time `json:"time"`
}

func (q *Queries) GetReservationsCountForUpdate(ctx context.Context, arg GetReservationsCountForUpdateParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReservationsCountForUpdate, arg.WeekdayID, arg.ServiceID, arg.Time)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getReserveTypes = `-- name: GetReserveTypes :many
SELECT id, name, created_at, updated_at FROM reserve_types
`

func (q *Queries) GetReserveTypes(ctx context.Context) ([]ReserveType, error) {
	rows, err := q.db.QueryContext(ctx, getReserveTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReserveType
	for rows.Next() {
		var i ReserveType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, name, created_at, updated_at FROM roles WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRoleByID(ctx context.Context, id int64) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRoleByID, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoles = `-- name: GetRoles :many
SELECT id, name, created_at, updated_at FROM roles
`

func (q *Queries) GetRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, getRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceByID = `-- name: GetServiceByID :one
SELECT id, user_id, description, subcategory_id, google_map_address, willaya, baladia, average_rating, created_at, updated_at FROM services WHERE id = $1 LIMIT 1
`

func (q *Queries) GetServiceByID(ctx context.Context, id int64) (Service, error) {
	row := q.db.QueryRowContext(ctx, getServiceByID, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Description,
		&i.SubcategoryID,
		&i.GoogleMapAddress,
		&i.Willaya,
		&i.Baladia,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getServiceByUserID = `-- name: GetServiceByUserID :many
SELECT id, user_id, description, subcategory_id, google_map_address, willaya, baladia, average_rating, created_at, updated_at FROM services WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetServiceByUserID(ctx context.Context, userID int32) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, getServiceByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Description,
			&i.SubcategoryID,
			&i.GoogleMapAddress,
			&i.Willaya,
			&i.Baladia,
			&i.AverageRating,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServices = `-- name: GetServices :many
SELECT id, user_id, description, subcategory_id, google_map_address, willaya, baladia, average_rating, created_at, updated_at FROM services ORDER BY id DESC OFFSET $2 LIMIT $1
`

type GetServicesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetServices(ctx context.Context, arg GetServicesParams) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, getServices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Description,
			&i.SubcategoryID,
			&i.GoogleMapAddress,
			&i.Willaya,
			&i.Baladia,
			&i.AverageRating,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubcategories = `-- name: GetSubcategories :many
SELECT subcategories.id, subcategories.name, subcategories.description, subcategories.category_id, subcategories.created_at, subcategories.updated_at, categories.name AS category_name
FROM subcategories
JOIN categories ON subcategories.category_id = categories.id
`

type GetSubcategoriesRow struct {
	ID           int64        `json:"id"`
	Name         string       `json:"name"`
	Description  string       `json:"description"`
	CategoryID   int32        `json:"category_id"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
	CategoryName string       `json:"category_name"`
}

func (q *Queries) GetSubcategories(ctx context.Context) ([]GetSubcategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubcategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubcategoriesRow
	for rows.Next() {
		var i GetSubcategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubcategoryByID = `-- name: GetSubcategoryByID :one
SELECT id, name, description, category_id, created_at, updated_at FROM subcategories WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSubcategoryByID(ctx context.Context, id int64) (Subcategory, error) {
	row := q.db.QueryRowContext(ctx, getSubcategoryByID, id)
	var i Subcategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT users.id, users.first_name, users.last_name, users.phone_number, users.email, users.password, users.role_id, users.created_at, users.updated_at, roles.name AS role_name
FROM users
JOIN roles ON users.role_id = roles.id
WHERE users.email = $1 LIMIT 1
`

type GetUserByEmailRow struct {
	ID          int64        `json:"id"`
	FirstName   string       `json:"first_name"`
	LastName    string       `json:"last_name"`
	PhoneNumber string       `json:"phone_number"`
	Email       string       `json:"email"`
	Password    string       `json:"password"`
	RoleID      int32        `json:"role_id"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	RoleName    string       `json:"role_name"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleName,
	)
	return i, err
}

const getUserByEmailAndPassword = `-- name: GetUserByEmailAndPassword :one
SELECT users.id, users.first_name, users.last_name, users.phone_number, users.email, users.password, users.role_id, users.created_at, users.updated_at, roles.name AS role_name
FROM users
JOIN roles ON users.role_id = roles.id
WHERE users.email = $1 AND users.password = $2
LIMIT 1
`

type GetUserByEmailAndPasswordParams struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type GetUserByEmailAndPasswordRow struct {
	ID          int64        `json:"id"`
	FirstName   string       `json:"first_name"`
	LastName    string       `json:"last_name"`
	PhoneNumber string       `json:"phone_number"`
	Email       string       `json:"email"`
	Password    string       `json:"password"`
	RoleID      int32        `json:"role_id"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	RoleName    string       `json:"role_name"`
}

func (q *Queries) GetUserByEmailAndPassword(ctx context.Context, arg GetUserByEmailAndPasswordParams) (GetUserByEmailAndPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailAndPassword, arg.Email, arg.Password)
	var i GetUserByEmailAndPasswordRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleName,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, first_name, last_name, phone_number, email, password, role_id, created_at, updated_at FROM users WHERE id = $1 LIMIT 1
`

// Read Operations
func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserIDByEmail = `-- name: GetUserIDByEmail :one
SELECT id FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserIDByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserIDByEmail, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, first_name, last_name, phone_number, email, password, role_id, created_at, updated_at FROM users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.Email,
			&i.Password,
			&i.RoleID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkdays = `-- name: GetWorkdays :many
SELECT id, service_id, name, open_to_work, day_id, start_time, end_time, max_clients, created_at, updated_at FROM workdays
`

func (q *Queries) GetWorkdays(ctx context.Context) ([]Workday, error) {
	rows, err := q.db.QueryContext(ctx, getWorkdays)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workday
	for rows.Next() {
		var i Workday
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Name,
			&i.OpenToWork,
			&i.DayID,
			&i.StartTime,
			&i.EndTime,
			&i.MaxClients,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkdaysByServiceID = `-- name: GetWorkdaysByServiceID :many
SELECT id, service_id, name, open_to_work, day_id, start_time, end_time, max_clients, created_at, updated_at FROM workdays WHERE service_id = $1 ORDER BY id
`

func (q *Queries) GetWorkdaysByServiceID(ctx context.Context, serviceID int32) ([]Workday, error) {
	rows, err := q.db.QueryContext(ctx, getWorkdaysByServiceID, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workday
	for rows.Next() {
		var i Workday
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Name,
			&i.OpenToWork,
			&i.DayID,
			&i.StartTime,
			&i.EndTime,
			&i.MaxClients,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkdaysInRange = `-- name: GetWorkdaysInRange :many
SELECT id, service_id, name, open_to_work, day_id, start_time, end_time, max_clients, created_at, updated_at FROM workdays
WHERE service_id = $1
`

func (q *Queries) GetWorkdaysInRange(ctx context.Context, serviceID int32) ([]Workday, error) {
	rows, err := q.db.QueryContext(ctx, getWorkdaysInRange, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workday
	for rows.Next() {
		var i Workday
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Name,
			&i.OpenToWork,
			&i.DayID,
			&i.StartTime,
			&i.EndTime,
			&i.MaxClients,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorksdayByID = `-- name: GetWorksdayByID :many
SELECT id, service_id, name, open_to_work, day_id, start_time, end_time, max_clients, created_at, updated_at FROM workdays WHERE id = $1
`

func (q *Queries) GetWorksdayByID(ctx context.Context, id int64) ([]Workday, error) {
	rows, err := q.db.QueryContext(ctx, getWorksdayByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workday
	for rows.Next() {
		var i Workday
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Name,
			&i.OpenToWork,
			&i.DayID,
			&i.StartTime,
			&i.EndTime,
			&i.MaxClients,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesByCategory = `-- name: SearchServicesByCategory :many
SELECT s.id, s.user_id, s.description, s.subcategory_id, s.google_map_address, s.willaya, s.baladia, s.average_rating, s.created_at, s.updated_at
FROM services s
JOIN subcategories sc ON s.subcategory_id = sc.id
JOIN categories c ON sc.category_id = $1 LIMIT $2 OFFSET $3
`

type SearchServicesByCategoryParams struct {
	CategoryID int32 `json:"category_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) SearchServicesByCategory(ctx context.Context, arg SearchServicesByCategoryParams) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, searchServicesByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Description,
			&i.SubcategoryID,
			&i.GoogleMapAddress,
			&i.Willaya,
			&i.Baladia,
			&i.AverageRating,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesBySubCategory = `-- name: SearchServicesBySubCategory :many
SELECT s.id, s.user_id, s.description, s.subcategory_id, s.google_map_address, s.willaya, s.baladia, s.average_rating, s.created_at, s.updated_at FROM services AS s JOIN subcategories AS sc ON s.subcategory_id = $1 LIMIT $2 OFFSET $3
`

type SearchServicesBySubCategoryParams struct {
	SubcategoryID int32 `json:"subcategory_id"`
	Limit         int32 `json:"limit"`
	Offset        int32 `json:"offset"`
}

func (q *Queries) SearchServicesBySubCategory(ctx context.Context, arg SearchServicesBySubCategoryParams) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, searchServicesBySubCategory, arg.SubcategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Description,
			&i.SubcategoryID,
			&i.GoogleMapAddress,
			&i.Willaya,
			&i.Baladia,
			&i.AverageRating,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAvergaeRating = `-- name: UpdateAvergaeRating :one
UPDATE services
    SET average_rating = (SELECT AVG(rating) FROM ratings WHERE service_id = $1)
    WHERE id = $1 RETURNING average_rating
`

func (q *Queries) UpdateAvergaeRating(ctx context.Context, serviceID int32) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, updateAvergaeRating, serviceID)
	var average_rating sql.NullFloat64
	err := row.Scan(&average_rating)
	return average_rating, err
}

const updateCategoryByID = `-- name: UpdateCategoryByID :exec
UPDATE categories
SET name = $1, description = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $3
`

type UpdateCategoryByIDParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdateCategoryByID(ctx context.Context, arg UpdateCategoryByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateCategoryByID, arg.Name, arg.Description, arg.ID)
	return err
}

const updateComplaintByID = `-- name: UpdateComplaintByID :exec
UPDATE complaints
SET service_id = $1, user_id = $2, type = $3, complaint = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $5
`

type UpdateComplaintByIDParams struct {
	ServiceID int32  `json:"service_id"`
	UserID    int32  `json:"user_id"`
	Type      string `json:"type"`
	Complaint string `json:"complaint"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateComplaintByID(ctx context.Context, arg UpdateComplaintByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateComplaintByID,
		arg.ServiceID,
		arg.UserID,
		arg.Type,
		arg.Complaint,
		arg.ID,
	)
	return err
}

const updateRatingByID = `-- name: UpdateRatingByID :exec
UPDATE ratings
SET service_id = $1, user_id = $2, rating = $3, comment = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $5
`

type UpdateRatingByIDParams struct {
	ServiceID int32          `json:"service_id"`
	UserID    int32          `json:"user_id"`
	Rating    int32          `json:"rating"`
	Comment   sql.NullString `json:"comment"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateRatingByID(ctx context.Context, arg UpdateRatingByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateRatingByID,
		arg.ServiceID,
		arg.UserID,
		arg.Rating,
		arg.Comment,
		arg.ID,
	)
	return err
}

const updateReservationByID = `-- name: UpdateReservationByID :exec
UPDATE reservations
SET service_id = $1, user_id = $2, time = $3, weekday_id = $4, ranking = $5, updated_at = CURRENT_TIMESTAMP
WHERE id = $6
`

type UpdateReservationByIDParams struct {
	ServiceID int32     `json:"service_id"`
	UserID    int32     `json:"user_id"`
	Time      time.Time `json:"time"`
	WeekdayID int32     `json:"weekday_id"`
	Ranking   int32     `json:"ranking"`
	ID        int64     `json:"id"`
}

func (q *Queries) UpdateReservationByID(ctx context.Context, arg UpdateReservationByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateReservationByID,
		arg.ServiceID,
		arg.UserID,
		arg.Time,
		arg.WeekdayID,
		arg.Ranking,
		arg.ID,
	)
	return err
}

const updateReserveStatusName = `-- name: UpdateReserveStatusName :exec
UPDATE reservations_status SET name = $1 WHERE id = $2
`

type UpdateReserveStatusNameParams struct {
	Name string `json:"name"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateReserveStatusName(ctx context.Context, arg UpdateReserveStatusNameParams) error {
	_, err := q.db.ExecContext(ctx, updateReserveStatusName, arg.Name, arg.ID)
	return err
}

const updateRoleByID = `-- name: UpdateRoleByID :exec
UPDATE roles
SET name = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateRoleByIDParams struct {
	Name string `json:"name"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateRoleByID(ctx context.Context, arg UpdateRoleByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateRoleByID, arg.Name, arg.ID)
	return err
}

const updateServiceByID = `-- name: UpdateServiceByID :exec
UPDATE services
SET user_id = $1, description = $2, google_map_address = $3, willaya = $4, baladia = $5, updated_at = CURRENT_TIMESTAMP
WHERE id = $6
`

type UpdateServiceByIDParams struct {
	UserID           int32  `json:"user_id"`
	Description      string `json:"description"`
	GoogleMapAddress string `json:"google_map_address"`
	Willaya          string `json:"willaya"`
	Baladia          string `json:"baladia"`
	ID               int64  `json:"id"`
}

func (q *Queries) UpdateServiceByID(ctx context.Context, arg UpdateServiceByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateServiceByID,
		arg.UserID,
		arg.Description,
		arg.GoogleMapAddress,
		arg.Willaya,
		arg.Baladia,
		arg.ID,
	)
	return err
}

const updateSubcategoryByID = `-- name: UpdateSubcategoryByID :exec
UPDATE subcategories
SET name = $1, description = $2, category_id = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $4
`

type UpdateSubcategoryByIDParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	CategoryID  int32  `json:"category_id"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdateSubcategoryByID(ctx context.Context, arg UpdateSubcategoryByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateSubcategoryByID,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.ID,
	)
	return err
}

const updateUserByID = `-- name: UpdateUserByID :exec

UPDATE users
SET first_name = $1, last_name = $2, phone_number = $3, email = $4, password = $5, role_id = $6, updated_at = CURRENT_TIMESTAMP
WHERE id = $7
`

type UpdateUserByIDParams struct {
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	PhoneNumber string `json:"phone_number"`
	Email       string `json:"email"`
	Password    string `json:"password"`
	RoleID      int32  `json:"role_id"`
	ID          int64  `json:"id"`
}

// Update Operations
func (q *Queries) UpdateUserByID(ctx context.Context, arg UpdateUserByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateUserByID,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Email,
		arg.Password,
		arg.RoleID,
		arg.ID,
	)
	return err
}

const updateWorkdayByID = `-- name: UpdateWorkdayByID :exec
UPDATE workdays
SET start_time = $1, end_time = $2, max_clients = $3, updated_at = CURRENT_TIMESTAMP, open_to_work = $4
WHERE id = $5
`

type UpdateWorkdayByIDParams struct {
	StartTime  time.Time `json:"start_time"`
	EndTime    time.Time `json:"end_time"`
	MaxClients int32     `json:"max_clients"`
	OpenToWork bool      `json:"open_to_work"`
	ID         int64     `json:"id"`
}

func (q *Queries) UpdateWorkdayByID(ctx context.Context, arg UpdateWorkdayByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateWorkdayByID,
		arg.StartTime,
		arg.EndTime,
		arg.MaxClients,
		arg.OpenToWork,
		arg.ID,
	)
	return err
}
